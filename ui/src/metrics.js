class MetricsManager {
  constructor() {
    this.metricsData = {};
  }

  mergeInMetrics(fetchedMetrics) {
    let addedNew = false;
    const mergedResults = {};
    // TODO: Handle missing keys on either side. This will remove metrics if
    // `fetchedMetrics` does not have the relevant metric.
    Object.entries(fetchedMetrics).forEach(([metricName, metricValues]) => {
      let current = null;
      if (this.metricsData[metricName] != null) {
        current = this.metricsData[metricName];
      } else {
        current = {
          timestamps: [],
          values: [],
        };
      }
      const fetched = metricValues;
      const merged = mergeMetrics(current, fetched);
      mergedResults[metricName] = merged;
      if (current.timestamps.length < merged.timestamps.length) {
        addedNew = true;
      }
    });
    if (addedNew) {
      this.metricsData = mergedResults;
    }
    return addedNew;
  }

  getMetricsInWindow(windowSize, extendForward) {
    // We assume metric values are all aligned. This should be the case because
    // the backend returns metrics with aligned timestamps.
    let maxWindowSize = windowSize;
    let maxTimestamp = null;
    for (const values of Object.values(this.metricsData)) {
      // Handle the case where we have fewer than `windowSize` entries.
      maxWindowSize = Math.min(values.timestamps.length, maxWindowSize);

      // Get the maximum timestamp (for extending).
      if (values.timestamps.length > 0 && maxTimestamp == null) {
        maxTimestamp = values.timestamps[values.timestamps.length - 1];
      }
    }

    const windowedData = {};
    for (const [metricName, values] of Object.entries(this.metricsData)) {
      const numPoints = values.timestamps.length;
      windowedData[metricName] = {
        timestamps: values.timestamps.slice(numPoints - maxWindowSize),
        values: values.values.slice(numPoints - maxWindowSize),
      };
    }

    if (
      !extendForward ||
      maxWindowSize === windowSize ||
      maxTimestamp == null
    ) {
      return windowedData;
    }

    const pointsToExtend = windowSize - maxWindowSize;
    const extraTimestamps = [];
    for (let i = 0; i < pointsToExtend; ++i) {
      const ts = new Date(maxTimestamp);
      ts.setMinutes(ts.getMinutes() + (i + 1));
      extraTimestamps.push(ts);
    }
    for (const [metricName, values] of Object.entries(this.metricsData)) {
      windowedData[metricName] = {
        timestamps: [...values.timestamps, ...extraTimestamps],
        values: values.values,
      };
    }
    return windowedData;
  }
}

export default MetricsManager;

function mergeMetrics(existingMetrics, fetchedMetrics) {
  // General merge function, generated by ChatGPT.
  const existingTimestamps = existingMetrics.timestamps;
  const existingValues = existingMetrics.values;
  const newTimestamps = fetchedMetrics.timestamps;
  const newValues = fetchedMetrics.values;

  const mergedTimestamps = [];
  const mergedValues = [];

  let existingIndex = 0;
  let newIndex = 0;

  while (
    existingIndex < existingTimestamps.length &&
    newIndex < newTimestamps.length
  ) {
    const existingTimestamp = existingTimestamps[existingIndex];
    const newTimestamp = newTimestamps[newIndex];

    if (existingTimestamp < newTimestamp) {
      mergedTimestamps.push(existingTimestamp);
      mergedValues.push(existingValues[existingIndex]);
      existingIndex++;
    } else if (existingTimestamp > newTimestamp) {
      mergedTimestamps.push(newTimestamp);
      mergedValues.push(newValues[newIndex]);
      newIndex++;
    } else {
      // Timestamps are equal. Ignore the fetched metric (it _should_ be equal).
      mergedTimestamps.push(existingTimestamp);
      mergedValues.push(existingValues[existingIndex]);
      existingIndex++;
      newIndex++;
    }
  }

  // Add remaining timestamps and values from the existing object
  while (existingIndex < existingTimestamps.length) {
    mergedTimestamps.push(existingTimestamps[existingIndex]);
    mergedValues.push(existingValues[existingIndex]);
    existingIndex++;
  }

  // Add remaining timestamps and values from the new object
  while (newIndex < newTimestamps.length) {
    mergedTimestamps.push(newTimestamps[newIndex]);
    mergedValues.push(newValues[newIndex]);
    newIndex++;
  }

  return {
    timestamps: mergedTimestamps,
    values: mergedValues,
  };
}
