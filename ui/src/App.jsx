import axios from "axios";
import { useState, useEffect } from "react";
import Header from "./components/Header";
import VirtualInfraView from "./components/VirtualInfraView";
import BlueprintView from "./components/BlueprintView";
import PerfView from "./components/PerfView";

import "./App.css";

const REFRESH_INTERVAL_MS = 30 * 1000;
const API_PREFIX = "/api/1";

function parseMetrics({ named_metrics }) {
  const result = {};
  Object.entries(named_metrics).forEach(([metricName, metricValues]) => {
    const parsedTs = metricValues.timestamps.map(
      (timestamp) => new Date(timestamp),
    );
    result[metricName] = {
      timestamps: parsedTs,
      values: metricValues.values,
    };
  });
  return result;
}

function mergeMetrics(existingMetrics, fetchedMetrics) {
  // General merge function, generated by ChatGPT.
  const existingTimestamps = existingMetrics.timestamps;
  const existingValues = existingMetrics.values;
  const newTimestamps = fetchedMetrics.timestamps;
  const newValues = fetchedMetrics.values;

  const mergedTimestamps = [];
  const mergedValues = [];

  let existingIndex = 0;
  let newIndex = 0;

  while (
    existingIndex < existingTimestamps.length &&
    newIndex < newTimestamps.length
  ) {
    const existingTimestamp = existingTimestamps[existingIndex];
    const newTimestamp = newTimestamps[newIndex];

    if (existingTimestamp < newTimestamp) {
      mergedTimestamps.push(existingTimestamp);
      mergedValues.push(existingValues[existingIndex]);
      existingIndex++;
    } else if (existingTimestamp > newTimestamp) {
      mergedTimestamps.push(newTimestamp);
      mergedValues.push(newValues[newIndex]);
      newIndex++;
    } else {
      // Timestamps are equal. Ignore the fetched metric (it _should_ be equal).
      mergedTimestamps.push(existingTimestamp);
      mergedValues.push(existingValues[existingIndex]);
      existingIndex++;
      newIndex++;
    }
  }

  // Add remaining timestamps and values from the existing object
  while (existingIndex < existingTimestamps.length) {
    mergedTimestamps.push(existingTimestamps[existingIndex]);
    mergedValues.push(existingValues[existingIndex]);
    existingIndex++;
  }

  // Add remaining timestamps and values from the new object
  while (newIndex < newTimestamps.length) {
    mergedTimestamps.push(newTimestamps[newIndex]);
    mergedValues.push(newValues[newIndex]);
    newIndex++;
  }

  return {
    timestamps: mergedTimestamps,
    values: mergedValues,
  };
}

function mergeAllMetrics(currentMetrics, fetchedMetrics) {
  let addedNew = false;
  const mergedResults = {};
  // TODO: Handle missing keys on either side. This will remove metrics if
  // `fetchedMetrics` does not have the relevant metric.
  Object.entries(fetchedMetrics).forEach(([metricName, metricValues]) => {
    let current = null;
    if (currentMetrics.hasOwnProperty(metricName)) {
      current = currentMetrics[metricName];
    } else {
      current = {
        timestamps: [],
        values: [],
      };
    }
    const fetched = metricValues;
    const merged = mergeMetrics(current, fetched);
    mergedResults[metricName] = merged;
    if (current.timestamps.length < merged.timestamps.length) {
      addedNew = true;
    }
  });
  return [mergedResults, addedNew];
}

function App() {
  const [metricsData, setMetricsData] = useState({});
  const [systemState, setSystemState] = useState({});

  useEffect(() => {
    let timeoutId = null;
    const refreshData = async () => {
      const resultState = await axios.get(`${API_PREFIX}/system_state`);
      const newSystemState = resultState.data;
      // TODO: Not the best way to check for equality.
      if (JSON.stringify(systemState) !== JSON.stringify(newSystemState)) {
        setSystemState(newSystemState);
      }

      const resultMetrics = await axios.get(`${API_PREFIX}/metrics`);
      const rawMetrics = resultMetrics.data;
      const fetchedMetrics = parseMetrics(rawMetrics);
      const [mergedMetrics, addedNewMetrics] = mergeAllMetrics(
        metricsData,
        fetchedMetrics,
      );
      if (addedNewMetrics) {
        setMetricsData(mergedMetrics);
      }

      timeoutId = setTimeout(refreshData, REFRESH_INTERVAL_MS);
    };

    // Run first fetch immediately.
    timeoutId = setTimeout(refreshData, 0);
    return () => {
      if (timeoutId === null) {
        return;
      }
      clearTimeout(timeoutId);
    };
  }, [metricsData, systemState]);

  return (
    <>
      <Header />
      <div class="body-container">
        <div class="column">
          <h2 class="col-h2">Data Infrastructure</h2>
          <div class="column-inner">
            <VirtualInfraView systemState={systemState} />
            <BlueprintView systemState={systemState} />
          </div>
        </div>
        <div class="column">
          <h2 class="col-h2">Performance Monitoring</h2>
          <div class="column-inner">
            <PerfView metricsData={metricsData} />
          </div>
        </div>
      </div>
    </>
  );
}

export default App;
